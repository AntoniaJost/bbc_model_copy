"""The exxploit_social_learning culture module has some dynamics."""

# This file is part of pycopancore.
#
# Copyright (C) 2016 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# License: MIT license

#
#  Imports
#

# from pycopancore import ODE, Step, Explicit, Event
from pycopancore import Step
from pycopancore.model_components import abstract
from .interface import Culture_
# from .interface import Individual_
import numpy as np

#
#  Define class Culture
#


class Culture(Culture_, abstract.Culture):
    """Define properties of exploit_social_learning culture.

    Inherits from Culture_ as the interface
    with all necessary variables and parameters.
    """

    #
    #  Definitions of internal methods
    #

    def __init__(self,
                 *,
                 step_width=2,
                 last_execution=None,
                 variable_culture=1.5,
                 culture_world=None,
                 **kwargs
                 ):
        """Initialize an instance of Culture."""
        super(Culture, self).__init__(**kwargs)
        self.step_width = step_width
        self.last_execution = last_execution
        self.variable_culture = variable_culture
        # culture.world is supposed to be the one world instance
        self.culture_world = culture_world

        print('exploit_social_learning culture initialized')

    def __repr__(self):
        """Return a string representation of the object of base.Culture."""
        return (super().__repr__() +
                'Exploit_social_learning.culture object'
                )

    #
    #  Definitions of further methods
    #

    # TODO:
    # Is this the right place here?
    # How should the social update be computed, eg. in several methods?
    def social_update(self, t):
        """Execute the social update.

        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        nt = self.step_timing(t)
        assert t == nt, "it's not time yet, t = %r and not %r" % (t, nt)
        self.last_execution = t
        self.variable_culture += 1
        # print('culture_world agent list: ',self.culture_world.agent_list)
        random_index = np.random.randint(10)
        individual_i = self.culture_world.agent_list[random_index]

        if self.culture_world.has_neighbor(individual_i):
            individual_j = self.culture_world.random_neighbor(individual_i)
            # compare strategies of i and j:
            # If they are the same, do nothing. Else change i's strategy.
            if individual_i.strategy != individual_j.strategy:
                if individual_i.rewiring_prob >= 0.1:
                    self.reconnect(individual_i, individual_j)
                else:
                    self.change_strategy(individual_i, individual_j)

    def reconnect(self, individual_i, individual_j):
        """Reconnect individual_i from individual_j and connect it to k.

        Disconnect individual_i from individual_j and connect individual_i
        to a randomly chosen individual_k with the same strategy,
        individual_i.strategy == individual_k.strategy.

        Parameters
        ----------
        individual_i
        individual_j

        Returns
        -------

        """
        # Disconnect individual_i and individual_j
        i = self.culture_world.agent_list.index(individual_i)
        j = self.culture_world.agent_list.index(individual_j)
        self.culture_world.contact_network[i, j] = 0
        self.culture_world.contact_network[j, i] = 0
        # Connect individual_i to a random individual_l with same strategy
        all_neighbors = self.culture_world.get_neighbors(individual_i)
        strategy_1 = individual_i.strategy
        for neighbor in all_neighbors:
            if neighbor.strategy != strategy_1:
                all_neighbors.remove(neighbor)
        print('all neighbors: ', all_neighbors)
        if all_neighbors == []:
            print('No possible neighbors with different strategy.')
        else:
            individual_k = np.random.choice(all_neighbors)
            print('individual k: ', individual_k)
            k = self.culture_world.agent_list.index(individual_k)
            self.culture_world.contact_network[i, k] = 1
            self.culture_world.contact_network[k, i] = 1

    def change_strategy(self, individual_i, individual_j):
        """Change strategy of individual_i to individual_j's.

        Change the strategy of individual_i to the strategy of individual_j
        depending on their respective harvest rates and the imitation tendency.

        Parameters
        ----------
        individual_i
        individual_j

        Returns
        -------

        """
        print('change strategy here:')
        probability = 0.5 * np.tanh(individual_i.imitation_tendency *
                                    (individual_j.harvest_rate -
                                     individual_i.harvest_rate) + 1)
        print('prob: ', probability)
        if probability >= 0.5:
            individual_i.strategy = individual_j.strategy

    def step_timing(self,
                    t):
        """Return the next time step is to be called.

        This function is used to geet to know when the step function is
        to be called.
        Parameters
        ----------
        t

        Returns
        -------

        """
        if isinstance(self.last_execution, type(None)):
            self.last_execution = 0
        if t < self.last_execution:
            print('last execution time after t!')
        return self.last_execution + self.step_width

    # TODO:
    # add the social processes here
    processes = [Step('Social Update is a step function',
                      [Culture_.culture_world],
                      [step_timing, social_update])]
