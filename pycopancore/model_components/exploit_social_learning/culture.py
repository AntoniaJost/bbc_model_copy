"""The exploit_social_learning culture module has some dynamics."""

# This file is part of pycopancore.
#
# Copyright (C) 2016 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# License: MIT license

#
#  Imports
#

# from pycopancore import ODE, Step, Explicit, Event
from pycopancore import Step
from pycopancore.model_components import abstract
from . import interface as IF
from pycopancore.model_components.base.interface import World as BWorld
import numpy as np
from scipy.sparse.csgraph import connected_components

#
#  Define class Culture
#


class Culture(IF.Culture, abstract.Culture):
    """Define properties of exploit_social_learning culture.

    Inherits from Culture as the interface
    with all necessary variables and parameters.
    """

    #
    #  Definitions of internal methods
    #

    def __init__(self,
                 *,
                 last_execution_time=None,
                 culture_world=None,
                 **kwargs
                 ):
        """Initialize an instance of Culture."""
        super(Culture, self).__init__(**kwargs)
        self.last_execution_time = last_execution_time
        # culture.world is supposed to be the one world instance
        self.culture_world = culture_world
        self.consensus = False

        print('exploit_social_learning culture initialized')

    def __repr__(self):
        """Return a string representation of the object of base.Culture."""
        return (super().__repr__() +
                'Exploit_social_learning.culture object'
                )

    #
    #  Definitions of further methods
    #

    def social_update(self, t):
        """Execute the social update.

        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        # nt = self.step_timing(t)
        # assert t == nt, "it's not time yet, t = %r and not %r" % (t, nt)
        # print('t: ', t, 'last execution: ', self.last_execution_time)
        self.last_execution_time = t
        agent_i = self.get_update_agent()

        # Step (1)
        if self.culture_world.has_neighbor(agent_i):
            agent_j = self.culture_world.get_random_neighbor(agent_i)
            # Step (2): Compare strategies of i and j:
            # If they are the same, do nothing. Else change i's strategy.
            if agent_i.strategy != agent_j.strategy:
                # Step (2.1)
                if np.random.random() < agent_i.rewiring_prob:
                    self.reconnect(agent_i, agent_j)
                # Step (2.2)
                else:
                    self.change_strategy(agent_i, agent_j)
        # Step (3)
        self.set_new_update_time(agent_i)
        # TODO:
        # What should happen if there is a consensus? How should the runner
        # handle this? At which moment exactly should one check for the
        # consensus? Before or after a social_update?
        print('Consensus: ', self.check_for_consensus())

    def reconnect(self, agent_i, agent_j):
        """Reconnect agent_i from agent_j and connect it to k.

        Disconnect agent_i from agent_j and connect agent_i
        to a randomly chosen agent_k with the same strategy,
        agent_i.strategy == agent_k.strategy.

        Parameters
        ----------
        agent_i : Agent (Individual or Society)
        agent_j : Agent (Individual or Society)

        Returns
        -------

        """
        # Find a random stranger agent_k with same strategy as agent_i
        all_non_neighbors = self.culture_world.get_non_neighbors(agent_i)
        strategy_i = agent_i.strategy
        for stranger in all_non_neighbors:
            if stranger.strategy != strategy_i:
                all_non_neighbors.remove(stranger)
        if not all_non_neighbors:
            print('No possible neighbors with different strategy.')
        else:
            # Disconnect agent_i and agent_j
            i = self.culture_world.agent_list.index(agent_i)
            j = self.culture_world.agent_list.index(agent_j)
            self.culture_world.contact_network[i, j] = 0
            self.culture_world.contact_network[j, i] = 0
            # Connect agent_i and agent_k
            agent_k = np.random.choice(all_non_neighbors)
            k = self.culture_world.agent_list.index(agent_k)
            self.culture_world.contact_network[i, k] = 1
            self.culture_world.contact_network[k, i] = 1

    def change_strategy(self, agent_i, agent_j):
        """Change strategy of agent_i to agent_j's.

        Change the strategy of agent_i to the strategy of agent_j
        depending on their respective harvest rates and the imitation tendency
        according to a sigmoidal function.

        Parameters
        ----------
        agent_i : Agent (Individual or Society)
            Agent i whose strategy is to be changed to agent j's strategy
        agent_j : Agent (Individual or Society)
            Agent j whose strategy is imitated
        Returns
        -------

        """
        probability = 0.5 * np.tanh(agent_i.imitation_tendency *
                                    (agent_j.harvest_rate -
                                     agent_i.harvest_rate) + 1)
        if np.random.random() < probability:
            agent_i.strategy = agent_j.strategy

    def get_update_agent(self):
        """Return the agent with the closest waiting time.

        Choose from all agents the one with the smallest update_time.
        Returns
        -------

        """
        next_agent = self.culture_world.agent_list[0]
        for agent in self.culture_world.agent_list:
            if agent.update_time < next_agent.update_time:
                next_agent = agent
        return next_agent

    def set_new_update_time(self, agent):
        """Set next time step when agent is to be called again.

        Set the attribute update_time of agent to
        old_update_time + new_update_time, where new_update_time is again
        drawn from an exponential distribution.

        Parameters
        ----------
        agent : Agent (Individual or Society)
            The agent whose new update_time should be drawn and set.

        Returns
        -------

        """
        # print('old_update_time: ',individual.update_time)
        new_update_time = np.random.exponential(agent.average_waiting_time)
        agent.update_time += new_update_time

    def check_for_consensus(self):
        """Check if the model has run into a consensus state.

        The model is in a consensus state if in each connected component
        all agents use the same strategy. In this case, there will be no more
        change of strategies since the agents are only connected to agents
        with the same strategy.

        Returns
        -------
        consensus : bool
            True if model is into consensus state, otherwise False
        """
        # TODO:
        # write this method less complex, maybe use notation from cyexploit.
        cc = connected_components(self.culture_world.contact_network,
                                  directed=False)
        unique, u_indices = np.unique(cc[1], return_index=True)
        # iterate through all connected components (i: index of component)
        for i in range(cc[0]):
            # iterate through all agents
            for j in range(len(cc[1])):
                # check if agent j belongs to component i
                if i == cc[1][j]:
                    # check if all agents of component i have the same strategy
                    if self.culture_world.agent_list[j].strategy \
                            != self.culture_world.agent_list[
                                u_indices[i]].strategy:
                        self.consensus = False
                        return self.consensus
        # If in each component, all agents have the same strategy, then a
        # consensus state is reached
        self.consensus = True
        return self.consensus

    def step_timing(self,
                    t):
        """Return the next time step is to be called.

        This function is used to get to know when the step function is
        to be called.
        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        if isinstance(self.last_execution_time, type(None)):
            self.last_execution_time = 0
        if t < self.last_execution_time:
            print('last execution time after t!')
        # return self.last_execution + self.step_width

        next_time = self.culture_world.agent_list[0].update_time
        for agent in self.culture_world.agent_list:
            if agent.update_time < next_time:
                next_time = agent.update_time
        if t > next_time:
            print('next update time before t!')
        # return float('inf')
        return next_time

    # add the social processes here
    # One needs to add the variables that can be changed by this process here:
    # the variables have to be called via the interface in which they are
    # defined, eg. the world's contact_network was defined in base.world,
    # so World_ is imported from base.interface as BWorld_
    processes = [Step('Social Update is a step function',
                      [IF.World.contact_network, IF.World.agent_list,
                       IF.Individual.strategy, IF.Individual.update_time,
                       IF.Culture.consensus],
                      [step_timing, social_update])]
