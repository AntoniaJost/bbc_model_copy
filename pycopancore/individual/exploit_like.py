# This file is part of pycopancore.
#
# Copyright (C) 2016 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# License: MIT license

"""
Encapsulates states and dynamics of the network between BinarySocialLearner in
an exploit like network_model
"""

#
#  Imports
#

import numpy as np
from abstract_culture import Culture
from binary_social_learner import BinarySocialLearner

#
#  Define class ExploitLike
#


class ExploitLike(Culture):
    """
    Encapsulates states and dynamics of the network between BinarySocialLearner
    in an exploit like network_model
    """

    #
    #  Definitions of internal methods
    #

    def __init__(self,
                 individual_connections=None,
                 rewiring_prob=None,
                 update_timescale=None):

        """
        Initializes an instance of ExploitLike:
        The objects of ExploitLike define connections and/or interactions
        between objects of class BinarySocialLearner in an exploit_like network

        Parameters
        ----------
        individual_connections: matrix or set of matrices?
            This is an array to describe different types of connections.
            Maybe several adjacency matrices will make sense, this is not
            yet clear.
        rewiring_prob: float
            The rewiring probability (needs to be between 0 and 1)
        update_timescale: float
            The update_timescale determines the individual_update_time due to a
            random exponential distribution.
        """

        super(ExploitLike, self).__init__(individual_connections)

        self.rewiring_prob = rewiring_prob
        self.update_timescale = update_timescale

    def __str__(self):
        """
        Return a string representation of the object of class ExploitLike
        """
        return (super(ExploitLike, self).__str__() +
                ('rewiring_prob % s, \
                 update_timescale % s '
                 ) % (
                self.rewiring_prob,
                self.update_timescale)
                )

    #
    # Function to create individuals
    #

    def create_individuals(self, number_individuals):
        """
        Creates a number of unconnected individuals

        Parameters
        ----------
        number_individuals: integer
            Number of individuals that is desired to be created
        """
        assert type(number_individuals) == int

        # Create individuals

        return ([BinarySocialLearner(i)
                for i in range(number_individuals)])

    #
    # Create the network between the individuals
    #

    def create_network(self, list_individuals, av_network_degree, phi):
        """
        Creates a network of individuals, that are assigned to groups and cells

        Prameters
        ---------
        list_individuals : list
            list of individuals that already have the following information
            written: cell_affiliation, group_affiliation
        av_network_degree : integer
            Define how many links/edges each individual has in average
        phi : float
            defines probability, that a link is inside the individuals own
            group
        """
        N_i = len(list_individuals)
        adj_mat = np.zeros(shape=(N_i, N_i))
        k = av_network_degree
        N_c = (k * N_i)/2
        N_co = 0
        while N_co <= N_c:
            i_1 = np.random.randint(0, N_i)
            p = np.random.rand()
            group_affiliation_i_1 = list_individuals(i_1).group_affiliation
            i_2 = np.random.randint(0, N_i)
            group_affiliation_i_2 = list_individuals(i_1).group_affiliation
            if i_1 == i_2:
                # Check for self-connection
                continue
            if i_2 in list_individuals[i_1].connections:
                # Check for double-connection
                continue
            if group_affiliation_i_1 == group_affiliation_i_2 and p < phi:
                # Create link
                list_individuals[i_1].add_individual_connection(i_2)
                list_individuals[i_2].add_individual_connection(i_1)
                adj_mat[i_2, i_1] = 1
                adj_mat[i_1, i_2] = 1
                N_co += 1
            if group_affiliation_i_1 != group_affiliation_i_2 and p >= phi:
                # Create link
                list_individuals[i_1].individual_connection.append(i_2)
                list_individuals[i_2].individual_connection.append(i_1)
                adj_mat[i_2, i_1] = 1
                adj_mat[i_1, i_2] = 1
                N_co += 1
            else:
                continue
        Culture.set_individual_connections(adj_mat)

    #
    #  Definitions of further methods
    #
