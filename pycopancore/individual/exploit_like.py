# This file is part of pycopancore.
#
# Copyright (C) 2016 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# License: MIT license

"""
Encapsulates states and dynamics of the network between BinarySocialLearner in
an exploit like network_model
"""

#
#  Imports
#

from abstract_culture import Culture
from binary_social_learner import BinarySocialLearner

#
#  Define class ExploitLike
#


class ExploitLike(Culture):
    """
    Encapsulates states and dynamics of the network between BinarySocialLearner
    in an exploit like network_model
    """

    #
    #  Definitions of internal methods
    #

    def __init__(self,
                 individual_connections,
                 rewiring_prob,
                 update_timescale):

        """
        Initializes an instance of ExploitLike:
        The objects of ExploitLike define connections and/or interactions
        between objects of class BinarySocialLearner in an exploit_like network

        Parameters
        ----------
        individual_connections: matrix or set of matrices?
            This is an array to describe different types of connections.
            Maybe several adjacency matrices will make sense, this is not
            yet clear.
        rewiring_prob: float
            The rewiring probability (needs to be between 0 and 1)
        """

        super(ExploitLike, self).__init__(individual_connections)

        self.rewiring_prob = rewiring_prob
        self.update_timescale = update_timescale

    def __str__(self):
        """
        Return a string representation of the object of class ExploitLike
        """
        return (super(ExploitLike, self).__str__() +
                ('rewiring_prob % s, \
                 update_timescale % s '
                 ) % (
                self.rewiring_prob,
                self.update_timescale)
                )

    #
    #  Definitions of further methods
    #
    
    def set_starting_conditions():
        BinarySocialLearner.individual_update_time =
        np.random.exponential(self.update_timescale)

    def run(self, steps=10000000):
        """
        asdasdasd
        """

    individual = BinarySocialLearner.individual_update_time.argmin()
    update_time = BinarySocialLearner.individual_update_time[individual]
    BinarySocialLearner.individual_update_time[individual] = np.


