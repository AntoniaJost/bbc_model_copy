Tutorial: Implementing and using a model from scratch
=====================================================

In this tuturial, we will implement and use a simple toy model from scratch,
learning about most of the essential features of copan:CORE.

The model we will implement is a version of the copan:EXPLOIT model described 
in `Wiedermann et al. (2015) 
<https://journals.aps.org/pre/abstract/10.1103/PhysRevE.91.052801>`_.


Overview and modularisation
---------------------------

Before actually starting the work, let us shortly get an overview of what needs 
to be done and understand the main structure of a model developed with 
copan:CORE.

Our model will have three **processes** ("things that happen"):

- *growth:* in each cell, a local resource stock grows, following the 
  continuous-time logistic growth model given by a certain ODE.

- *fishing:* each individual employs a certain effort to harvest the 
  resource growing in its cell, leading to individual catchs and an additional 
  fishing terms in the stock's ODE.
  
- *learning:* at random points in time given by a Poisson process,  
  each *i* in a random sample of individuals compares 
  her catch with that of randomly chosen acquaintance *j*,
  and copies *j*'s effort level with a probability depending on the difference 
  in catchs.

In pycopancore, the entities ("things that are") of a model are distinguished
by their **entity-type**. Of its four built-in entity-types, we only use two:

- ``Cell``, representing the place where a local resource stock is located 
  (corresponding to a *fish pond* in the Wiedermann paper),
- ``Individual``, representing a person fishing some local resource 
  (corresponding to a *fishing village* in the Wiedermann paper).

(Later on, we may also want to add some processes acting on the level of the
entity-types ``SocialSystem`` and ``World``, but we keep it simple for now.)

The main dynamic **variables** of the model will thus be

- ``Cell.fish_stock``
- ``Individual.fishing_effort``
- ``Individual.catch``: the catch

plus some fixed parameters which will also be treated as variables formally and 
introduced later.

To describe the relationships between cells and individuals, we make use of the 
following entity attributes shipped with copan:CORE's ``base`` model component:

- ``Individual.cell``: the home cell of the individual
- ``Cell.individuals``: list of all individuals living in the cell (in the 
  Wiedermann paper, only one fishing village has access to each fish pond, 
  but here we also allow several individuals to harvest in the same cell)
- ``Individual.culture``: the unique ``Culture`` process taxon relevant for all 
  individuals
- ``Culture.acquaintance_network``: the social network connecting the 
  individuals

In pycopancore, each variable and each process is *owned* by some object, 
most often an entity of a type such as ``Cell``, but sometimes by a so-called
*process taxon* such as ``Culture``. E.g., the inbuild ``acquaintance_network``
is owned not by any particular individual but by ``Culture`` itself, and 
individuals can access it via the *reference variable* named ``culture`` that
is owned by ``Individual``.

Since the three processes are only connected via the three variables and are 
otherwise independent, and since we may want to replace one of them by a 
different version later on (e.g., replace logistic growth by some other growth 
model or replace the particular form of social learning by some other form of 
learning), we will implement each process in its own model component and then 
plug them together to form the actual model.

So our **model components** will be

- **my_exploit_growth**: growth of ``Cell.fish_stock`` via an ODE

- **my_exploit_fishing**: computation of ``Individual.catch`` given 
  ``Individual.fishing_effort`` and corresponding reduction of 
  ``Cell.fish_stock`` via an ODE

- **my_exploit_learning**: for each ``Individual``, identify next time point 
  for learning, then, at that time point, draw a neighbour from 
  ``Culture.acquaintance_network``, compare own and neighbour's 
  ``catch`` and update own ``fishing_effort``.

Each model component will become a python subpackage of 
``pycopancore.model_components``, represented by a folder of the same name,
which mainly contains ... 

- a file ``model.py`` that defines which entity-types and process taxa the 
  component uses.

- a further subpackage called ``interface``that contains the 
  *interface classes* for all these entity-types and process taxa,
  describing what variables the component reads and writes;
  
- another subpackage called ``implementation`` that contains the 
  *implementation classes* for all these entity-types and process taxa,
  implementing the processes of the component. 
  
  
While the ``interface`` subpackage is typically represented by a single file 
``interface.py`` containing several short class definitions, the 
``implementation`` subpackage is typically represented by a subfolder 
``implementation`` that contains a separate file for each entity-type or 
process taxon with a single, longer class definition.

(Later on, when composing the actual model from the three model components, all 
classes contributing to the same entity-type will be *mixed* together via 
multiple inheritance, hence they will also be called *mixin* classes.)

In the **interface classes**, each variable is listed in one of three possible 
ways, each of which we will use for some variables:

- by reference to an existing variable definition from the *master data model*;
- by reference to an existing variable definition in another model component;
- by giving a new variable definition via instantiating the ``Variable`` class 
  and specifying all relevant meta-data for the variable.
  
In the **implementation classes**, we will implement the process logics using a 
number of different techniques suitable for different types of processes
(ODEs, algebraic equations, and rules for agent behaviour):

- the logistic growth ODE will be implemented in imperative-programming style 
  via a *method* of ``Cell`` that computes the RHS of the equation and stores 
  it in the special variable ``self.d_fish_stock``.

- the formula for the catch of all individuals in a cell will instead be given 
  in declarative-programming style by a simple *symbolic expression* 
  in the class ``Cell``, and the ODE for fishing will use the same expression.
  
- learning will be implemented via three methods, 
  one in ``Culture`` that returns the next time point for learning,
  another in ``Culture`` that selects the individuals that learn,
  and one in ``Individual`` that performs the actual learning.

We will see that there are often several alternative ways for implementing
a certain process and several alternative classes that could 'own' the process. 

(Although we need to implement the individual processes, we do *not* need to 
take care of how these equations get solved or when the different methods must 
be called, since that is the job of copan:CORE's inbuilt *runner*.)

After having implemented the three model components, we will compose from it 
the actual **model**. Just like model components are subpackages of 
``pycopancore.model_components``, a model is a subpackage of 
``pycopancore.models`` and is typically defined in a single python file inside 
the folder ``pycopancore/models``. The model definition will mainly import the 
necessary model components and will compose the final implementation classes of 
all entity-types and process taxa from the mixin classes provided by the 
components.

Finally, we will write a python script ``run_my_exploit.py`` that performs a 
simple **study** by running the model with some particular initial condition 
and parameter values and plotting some results. Such study scripts can be 
stored in the ``studies`` folder outside the pycopancore package.

Summarizing, we will first act as *model component developer*, then as 
*model composer*, and finally as *model end user*, and will eventually have 
written the following files (omitting certain secondary files we will learn 
about later)::

    pycopancore (repository folder)
    
      pycopancore (main package folder)
      | model_components
      | | my_exploit_growth
      | | | implementation
      | | | | cell.py
      | | | | environment.py
      | | | interface.py 
      | | | model.py
      | | my_exploit_fishing
      | | | implementation
      | | | | cell.py
      | | | | individual.py
      | | | | metabolism.py
      | | | interface.py 
      | | | model.py            
      | | my_exploit_learning
      | | | implementation
      | | | | culture.py
      | | | | individual.py
      | | | interface.py 
      | | | model.py            
      | models
      | | my_exploit.py
          
      studies (folder for studies)
      | run_my_exploit.py
      
Nicely, we can make use of some templates provided in the ``templates`` 
folder::

      templates (folder containing stuff to be copied and adjusted)
      | model_components
      | | SOME_COMPONENT (template for a model component folder)
      | | | ...
      | models
      | | SOME_MODEL.py (template for a model)
      | studies
      | | SOME_STUDY.py (template for a study)
      
So, let's go!


Implementing the growth component
---------------------------------

We start by doing some simple preparations:

- ``git clone https://github.com/pik-copan/pycopancore.git``

- ``cd pycopancore``

- ``cp -r templates/model_components/SOME_COMPONENT pycopancore/model_components/my_exploit_growth``

- In the copied subfolder ``implementation``, we delete those files we won't 
  need since they belong to entity-types and process taxa that we don't use in 
  this component: ``culture.py``, ``individual.py``, ``metabolism.py``, 
  ``social_system.py``, ``world.py``.

- We also remove the corresponding imports from ``implementation/__init__.py``, 
  keeping only these two imports::
  
    from .cell import Cell

    from .environment import Environment
  
- Similarly, in ``model.py``, we follow the ``# TODO:`` comments and delete the 
  unneeded imports and list entries, so that it basically contains this code 
  (plus comments and docstrings omitted here)::
  
    from . import interface as I
    from .implementation import Cell
    from .implementation import Environment   
    
    class Model (I.Model):
        entity_types = [Cell]
        process_taxa = [Environment]

Now the actual work begins by writing the component's **interface**, 
so open ``interface.py`` and do the following:

- In ``class Model``, 
  fill in a name and description for the component, like::
  
    name = "my exploit: growth"
    description = "growth component of the exploit tutorial model"

- Delete the class definitions of all unused entity-types and process taxa, 
  only keeping those of ``Cell`` and ``Environment``.
  
In ``class Cell``, we need to define the variable ``fish_stock``. Since it is 
a metaphorical variable representing a not further specified type of resource 
we just call ``fish`` for convenience, we should *not* use any of the existing 
specific stock variables from the master data model, such as 
``terrestrial_carbon_stock``, but we should define it as a new variable owned 
by this component. Still, we are thorough and give it an appropriate physical 
dimension (``fish``) and unit (``t_fish``), so that it gets not mixed up with 
other quantities in ways that make no sense. Therefore:

- Add in the header of ``Cell.py``::

    from ...data_model import Dimension, Unit

    fish = Dimension("fish", # name
                     "mass of fish") # description
    fish.default_unit = t_fish = \
        Unit("t fish", "metric tonnes of fish", symbol="t")
    
- Comment out the line::

    ONECELLVARIABLE = master_data_model.Cell....

- Uncomment the lines::

    from ... import Variable
    
    PERSONALCELLVARIABLE = Variable(...
    
- Edit the latter to read::

    fish_stock = Variable(
        "fish stock",
        "stock of a generic local resource 'fish' that can grow and be harvested",
        unit = t_fish,
        lower_bound = 0,
        is_extensive = True)

The names given as the first arguments of ``Dimension``, ``Unit`` and 
``Variable`` will be used in labels and log, while the descriptions given next 
appear in the automatically generated API documentation and are mainly intended 
as documentation for other users. We state that the stock cannot get negative,
and by saying ``is_extensive = True`` we state that this is a physically 
extensive quantity, i.e., that it is meaningful to add up resource stocks of 
different cells, e.g., to report the total stock. (We will encounter 
non-extensive quantities later, and in the API documentation of ``Variable``, 
further possible metadata are described.)

We will add further variables here later whenever we need them, so best keep 
``interface.py`` open. We turn to the **implementation** now by opening 
``implementation/cell.py``. Here, we will implement the logistic growth of 
``fish_stock``, which we could do either via a method or a symbolic expression.
We chose to do it by specifying the corresponding term in the ODE for 
``fish_stock`` via a *method* of ``Cell``:

- In ``implementation/cell.py``, add the following method to ``class Cell``::

    def grow(self, unused_t):
        competition_factor = 1 - self.fish_stock / self.fish_capacity
        growth_rate = self.environment.basic_fish_growth_rate * competition_factor
        self.d_fish_stock += growth_rate * self.fish_stock
  
- In the list ``processes = []``, add the following list entry::

    ODE("fish growth", [fish_stock], grow)

With the latter entry, we declare that ``fish_stock`` changes according to an
ordinary differential equation and that the method ``grow`` adds a term to this 
differential equation. Note that the method does so not by *returning* the term 
but by explicitly adding it to the special attribute ``Cell.d_fish_stock`` 
which represents the time derivative of ``Cell.fish_stock``. Note also that we 
only *add* (``+=``) to ``Cell.d_fish_stock`` rather than overriding its value 
(``=``), since other processes may want to add further terms to the same ODE
(and indeed we will do so later ourselves!).

When running the model, pycopancore will automatically call this method from 
within its ODE solver, giving it the current model time as the only argument. 
Since our ODE is time-independent, we don't make use of that argument and hence 
name it ``unused_t`` to indicate this (otherwise we would have named it just 
``t``).

Since in ``grow``, we use two parameters, ``self.fish_capacity`` and 
``self.environment.basic_fish_growth_rate``, we need to specify them:

- In ``interface.py``, add::

    class Cell ...
    
        # exogenous variables / parameters:
        fish_capacity = Variable("fish capacity", 
            "limit to fish stock due to competition for resources",
            unit = t_fish,
            lower_bound = 0,
            is_extensive = True,
            default = 100 * t_fish)
            
    class Environment ...
    
        # exogenous variables / parameters:
        basic_fish_growth_rate = Variable("basic fish growth rate",
            "basic rate at which fish would grow without competition",
            unit = t_fish / D.years,
            lower_bound = 0,
            is_intensive = True,
            default = 1.0 * t_fish / D.months)
            
While we treat the capacity as a cell variable that may vary from cell to cell,
we treat the basic growth rate as some kind of natural constant which belongs
to the environment rather than a particular cell, and we access it in the 
method ``grow`` via the inbuilt reference variable ``environment`` of 
``Cell`` by writing ``self.environment.basic_fish_growth_rate``.

Note that growth rates are *intensive* (rather than extensive), which means 
that they do not add up when adding stocks, but would rather lead to some kind 
of effective rate that could be computed by averaging the individual rates in 
an appropriate way.

For parameters, one often wants to specify default values, which we have done 
here. Bounds and default values can either be specified as pure numbers (like 
``0``), in which case they are assumed to be in the unit specified under 
``unit=``, or as *dimensional quantities* (like ``1.0 * t_fish / D.months``, 
meaning one ton of fish per month), in which case the unit of the dimensional 
quantity must belong to the same physical dimension as the unit specified under 
``unit=``. In the latter case, pycopancore automatically takes care of the 
necessary conversions, hence we encourage you to always specify values in the 
units your source data provides in order to make them more easily verifiable 
for the reader and avoid conversion mistakes.

As you can see, units can also be multiplied and divided to create suitable 
units for derived dimensions. E.g., in the case of ``basic_fish_growth_rate``, 
the correct dimension is fish per time, so we can use units such as 
``t_fish / D.years``, ``t_fish / D.months``, etc.
We don't need to define the time dimension and units ourselves but use those 
provided by pycopancore's master data model, which is here imported under the
abbreviation ``D``.

Note that when working with units and dimensional quantities, some *caution* is 
necessary: pycopancore distinguishes between *units* such as metres, seconds, 
tonnes, etc., and *dimensional quantities* such as 'one metre', 'two seconds', 
'half a tonne', etc. Values of variables, including bounds and default values,
must be of type ``DimensionalQuantity`` and can be generated by multiplying 
an object of type ``Unit`` (such as ``seconds``) with a number *from the left*,
e.g., ``2 * D.seconds`` (two seconds), or dividing a number by a unit, e.g., 
``50 / D.seconds`` (fifty Hertz). So ``D.metres`` is the length unit of metres, 
while ``1 * D.metres`` is the dimensional quantity of one metre, which is 
identical to ``.001 * D.kilometers``. However, since we also want to be able to 
derive larger from smaller units, multiplying a unit with a number from the 
*right*, or dividing a unit by a number, gives a new ``Unit`` rather than a 
dimensional quantity. Indeed, ``D.kilometers`` is defined in the master data 
model basically as ``kilometers = meters * 1000``. Hence, the dimensional 
quantity 'half a kilogram' must be written ``0.5 * D.kilograms``, while the 
German unit 'Pfund' ('half-kilograms') could be defined as ``D.kilograms / 2``.
A typical mistake is to try specifying the unit of a rate as ``1 / D.years``,
(which pycopancore interprets as the dimensional quantity of 'once per year'),
while the correct specification would be ``D.years ** (-1)``. Still, when you 
divide *two units* (rather than a number and a unit), you get a unit.
Hence it was correct for us to specify the unit of the base rate above as 
``t_fish / D.months`` (tonnes of fish per month).

Now that we have finished the first component, let's move on to the second.


Implementing the fishing component
----------------------------------

In this part, we will add another component in which each cell uses
all corresponding individuals' fishing effort levels to determine 
their individual catchs and the decline of the fish stock.

- Just as before, copy the template to a new model component 
  ``model_components/my_expoit_fishing``, this time keeping only the following 
  entity-types and process taxa: ``Cell``, ``Individual``, ``Metabolism``.

- In its ``interface.py``, uncomment and add the following imports and 
  variables::

    from ... import master_data_model as D
    import ..my_exploit_growth.interface as G
     
    class Individual...

        # endogenous:    
        catch = Variable("fishing catch", 
            "flow of fish received due to fishing",
            unit = G.t_fish / D.months,
            lower_bound = 0,
            is_extensive = True)

        # exogenous:
        fishing_effort = Variable("fishing effort",
            "effort spent fishing",
            unit = D.person_hours / D.weeks,
            lower_bound = 0,
            is_extensive = True,
            default = 40 * D.person_hours / D.weeks)
            
    class Cell...
    
        # endogenous:
        fish_stock = G.Cell.fish_stock
        total_fishing_effort = Individual.fishing_effort.copy()
        total_catch = Individual.catch.copy()
        
    class Metabolism...
    
        # exogenous:
        catch_cost_coeff = Variable(
            "catch cost coeff.",
            """coefficient c of quadratic fishing cost function
            effort = c * catch**2""",
            unit = (D.person_hours / D.weeks) / (G.t_fish / D.weeks)**2,
            lower_bound = 0,
            default = 40)  # so 40 hrs per week catch one tonne per week

Several things can be learned from this:

- Different units of the same dimension work seemlessly together (like 
  ``months`` and ``weeks``).
  
- Derived units can be quite complex and can be specified as fractions which
  need not be reduced (pycopancore takes care of that automatically). E.g., 
  the unit ``(D.person_hours / D.weeks) / (G.t_fish / D.weeks)**2``)
  could also have been written ``D.person_hours * D.weeks / G.t_fish**2`` 
  which would however be less transparent.
  
- If one component needs to access a Variable defined in another component,
  it needs to import the other component's interface and *use the same* 
  variable as seen in this line::
  
    fish_stock = G.Cell.fish_stock

- To define a *new* variable that has the same metadata as an existing one,
  e.g., since it is just an aggregation of the other variable to another 
  level, one can *copy* the other variable's *metadata* as seen in this line::

    total_fishing_effort = Individual.fishing_effort.copy()

- The differences between referencing a variable and copying its metadata are:

    - When a component uses an existing variable, there is still just one 
      variable that both components have access to in order to exchange data. 
      Therefore, the variable must have the *same identifier* in all components
      that use it: ``fish_stock``.
      
    - When you copy a variable's metadata via ``copy()``, you get a new 
      variable that is totally independent of the original one and can have 
      *any identifier* you like. (If one wants one to be the aggregation of the
      other, one has to specify this relationship explicitly via an equation,
      see below for an example.)
      
We can now implement the fishing process, and this time we will specify the
corresponding equations not via methods but as symbolic expressions. The
catches of individuals fishing in the same cell will not be independent but 
will depend on the total effort of all individuals fishing in that cell, to 
reflect competition for best catch locations. Therefore, we model the process
as partially owned by the entity-type ``Individual`` and partially owned by the
entity-type ``Cell``. 

- In ``implementation/cell.py``, add an import and three entries to the list of
  ``processes``::

    import sympy as sp  # to be able to use sp.sqrt
    from ...base import interface as B  # to be able to use B.Cell.metabolism

    class Cell...
    
        processes = [
            Explicit("total effort", 
                [I.Cell.total_fishing_effort],
                [B.Cell.sum.individuals.fishing_effort]),
            Explicit("total catch",
                [I.Cell.total_catch],
                [sp.sqrt(I.Cell.total_fishing_effort 
                      / B.Cell.metabolism.catch_cost_coeff)]),
            ODE("stock decline due to fishing",
                [I.Cell.fish_stock]
                [- I.Cell.total_catch])
        ]

Again, some things can be learned here:

- ODEs can either be specified via methods (as before) or via symbolic 
  expressions (as here). In the latter case, the third argument of the ``ODE``
  specification is not the name of a method but a list of symbolic expressions,
  one for each entry in the list of dependent variables (2nd argument of 
  ``ODE``). In our case, there's one dependent variable, ``I.Cell.fish_stock``,
  and one rather simple symbolic expression, ``-I.Cell.total_catch``.
  
- Similarly, processes that define some variables directly (rather than their 
  time derivative) as functions of some other variables are specified via the 
  process type ``Explicit``, and here again the third argument is either a 
  method that sets the dependent variables directly, or a list of symbolic 
  expressions. Above, we have said via a symbolic expression that 
  ``total_fishing_effort`` equals the sum of all the cell's individuals' 
  ``fishing_effort``s. Alternatively, we could have specified the same as::
  
    import numpy as np
    
    class Cell...
    
        def total_effort (self, unused_t):
            self.total_fishing_effort = np.sum(
                [i.fishing_effort for i in self.individuals])
                
        processes = [
            Explicit("total effort", 
                [I.Cell.total_fishing_effort],
                total_effort),
            ...
        ]
  
- Generally, a symbolic expression is basically a piece of code constructed 
  from these possible ingredients:
  
  - Variables defined in an interface such as ``I.Cell.total_catch``
  - Variables of other entity-types or process taxa (e.g. 
    ``Metabolism.catch_cost_coeff``) accessed via an inbuilt reference variable
    defined in the base component (e.g. ``B.Cell.metabolism``),
    leading to a so-called *dot-construct* such as 
    ``B.Cell.metabolism.catch_cost_coeff``.
  - Aggregation keywords specified as part of a dot-construct, such as ``sum``
    in ``B.Cell.sum.individuals.fishing_effort``. Valid aggregations for
    numerical variables are ``sum``, ``mean``, ``median``, ``min``, ``max``, 
    ``std`` and ``var``, and the aggregation keyword must be followed by a
    set-valued reference variable such as ``individuals``, ``cells``, etc.
  - Mathematical functions provided by the ``sympy`` package, such as 
    ``sp.sqrt``. (Caution: do *not* use ``numpy`` functions in symbolic expr.!)
  - Standard operators and numerals such as ``+``, ``**``, ``12.345`` etc.
    
We complete the implementation of the fishing component like this:

- In ``implementation/individual.py``, add::

    from ...base import interface as B
    
    class Individual...
    
        processes = [
            Explicit("individual catch",
                [I.Individual.catch],
                [B.Individual.cell.total_catch 
                 * I.Individual.fishing_effort 
                 / B.Individual.cell.total_fishing_effort])
        ]
        
(Note that alternatively, we could have achieved the same effect by letting
``Cell`` own this part of the process as well::

    class Cell...
    
        processes = [
            ...
            Explicit("individual catch",
                [B.Cell.individuals.catch],
                [I.Cell.total_catch 
                 * B.Cell.individuals.fishing_effort 
                 / I.Cell.total_fishing_effort])
        ]

In this version, each cell 'hands out' the catch to all its corresponding
individuals, so the target variable reads ``B.Cell.individuals.catch``
instead of ``I.Individual.catch``. If you compare the two versions, you will
notice that in the first version, all occurring variables and dot-constructs
start with ``Individual``, while in the second they all start with ``Cell``.
As a general rule, all variables and dot-constructs occurring in a process
owned by some entity-type process taxon must start with that entity-type or
process taxon and can access other entity-types' or process taxons' variables
only via reference variables.)


Implementing the learning component
-----------------------------------

The third and last component we implement models in an agent-based fashion how 
individuals learn their ``fishing_effort`` from each other. Again, we use the
template to prepare the component, this time with a larger number of 
parameters:

- On the basis of the template, make another model component 
  ``model_components/my_expoit_learning``, this time only keeping the  
  entity-type ``Individual`` and the process taxon ``Culture``.

- In its ``interface.py``, uncomment and add the following imports and 
  variables::

    from ... import Variable
    from ... import master_data_model as D
    import ..my_exploit_fishing.interface as F

    class Individual...

        # endogenous:
        fishing_effort = F.Individual.fishing_effort    

        # exogenous:
        catch = F.Individual.catch
        
    class Culture...
    
        # endogenous:
        acquaintance_network = D.Culture.acquaintance_network
        
        # exogenous:
        fishing_update_rate = Variable("fishing effort update rate",
            """average number of time points per time where some individuals 
            update their fishing effort""",
            unit = D.years**(-1), default = 1 / D.years, lower_bound = 0)
        fishing_update_prob = Variable(
            "fishing effort update probability",
            """probability that an individual updates their fishing effort at
            an update time point""",
            default = 1/2, lower_bound = 0, upper_bound = 1)
        fishing_exploration_prob = Variable(
            "fishing effort exploration probability",
            """probability that an individual copies a neighbours effort if
            both catches are equal""",
            default = 10 * D.percent, lower_bound = 0, upper_bound = 1)
        fishing_imitation_char_prob = Variable(
            "fishing effort imitation characteristic probability",
            """probability that an individual copies a neighbours effort if
            the other's catch is twice the own catch""",
            default = 90 * D.percent, lower_bound = 0, upper_bound = 1)
            
The learning process consists of two parts: 

- With an average rate of
  ``fishing_update_rate``, an 'update time point' occurs in the ``Culture``.
  When that happens, each ``Individual`` (``self``) updates their fishing 
  effort with a probability of ``fishing_update_prob``. 
- If she updates, she draws a random neighbour of hers (``other``) from the 
  ``acquaintance_network``. Then she copies ``other``'s ``fishing_effort`` 
  with a probability ``imitation_prob(catch_ratio)``, where ``catch_ratio`` 
  equals ``other.catch / self.catch`` and the function ``imitation_prob``
  is sigmoid-shaped and monotonic and returns zero for ``catch_ratio == 0``, 
  ``fishing_exploration_prob`` iff ``catch_ratio == 1``, 
  ``fishing_imitation_char_prob`` iff ``catch_ratio == 2``
  and 1 for ``catch_ratio = np.inf``.
  
The first part we implement as follows, using the process type ``Event``:

- In ``implementation/culture.py``::

    from numpy.random import exponential, uniform
    
    class Culture...
    
        def next_fishing_update_time(self, t):
            return t + exponential(1 / fishing_update_rate)
            
        def update_fishing_efforts(self, unused_t):
            for i in self.individuals:
                if uniform() < self.fishing_update_prob:
                    i.update_fishing_effort()
                    
        processes = [
            Event("update fishing effors",
                   [B.Culture.individuals.fishing_effort],
                   ["time",
                    next_fishing_update_time,
                    update_fishing_efforts])
        ]

An ``Event`` is something that happens at certain discrete time points. In our
case, its specification names two methods, one which returns the next time 
point at which the event happens (``next_fishing_update_time``), and one which
implements what happens at those time points (``update_fishing_efforts``).
The latter method finds out which individuals actually update and calls their
``update_fishing_effort`` method, which we will implement next:

- In ``implementation/individual.py``::

    from numpy import exp, log
    from numpy.random import choice

    class Individual...
    
        def fishing_imitation_prob(self, catch_ratio):
            offset = -log(1/self.culture.fishing_exploration_prob - 1)
            slope = -(log(1/self.culture.fishing_imitation_char_prob - 1) 
                      + offset) / log(2)
            return 1 / (1 + exp(- offset - slope*log(catch_ratio)))
        
        def update_fishing_effort(self):
            other = choice(list(
                self.culture.acquaintance_network.neighbors(self)))
            if uniform() < self.fishing_imitation_prob(other.catch / self.catch):
                self.fishing_effort = other.fishing_effort
                
