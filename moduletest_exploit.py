"""Moduletest for the exploit model.

A study to test the runner with the exploit model.
It includes the module components exploit_social_learning,
most_simple_vegetation and simple_extraction.
"""

import numpy as np
import networkx as nx
import time

from pycopancore.models import exploit
from pycopancore.runners.runner import Runner

start_time = time.time()

nc = 20
ni_sust = 10
ni_nonsust = 10

# Order of instantiating is important:
# world (later adding the attributes agent_list and contact_network)
# cells
# individuals
# societies
# Setting attributes of entity types that were not permitted before.
# initializing the model
# parameters of culture

world = exploit.World()

cells = [exploit.Cell(stock=1, capacity=1, growth_rate=1, world=world)
         for c in range(nc)]
individuals = [exploit.Individual(strategy=0, imitation_tendency=0,
                                  rewiring_prob=0.5,
                                  cell=cells[i]) for i in range(ni_nonsust)]\
              + [exploit.Individual(strategy=1, imitation_tendency=0,
                                    rewiring_prob=0.5,
                                    cell=cells[i+ni_nonsust])
                 for i in range(ni_sust)]
for (i, c) in enumerate(cells):
    c.individual = individuals[i]
p = 0.4     # link density
B = nx.adj_matrix(nx.erdos_renyi_graph(ni_sust+ni_nonsust, p))
A = B.toarray()
world.contact_network = A
world.agent_list = individuals

print('initializing model now:')
m = exploit.Model()
# Set the parameters in Culture:
m._process_taxon_objects[exploit.Culture].culture_world = world
# m._process_taxon_objects[exploit.Culture].acquaintance_network = B
print('\n runner starting')

print('m_proc txon...', m._process_taxon_objects[exploit.Culture])
# Define termination signals as list [ signal_method, object_method_works_on ]
signal_consensus = [exploit.Culture.check_for_consensus,
                    m._process_taxon_objects[exploit.Culture]]
# Define termination_callables as list of all signals
termination_callables = [signal_consensus]
print('term_callables: ', termination_callables)
r = Runner(model=m, termination_calls=termination_callables)
prep_time = time.time() - start_time
print('Time for configuring etc: %s seconds' % prep_time)
before_run_time = time.time()
traj = r.run(t_1=100, dt=.1)
run_time = time.time() - before_run_time  # runtime in seconds
run_time_min = run_time / 60
print('Time for run: %s seconds' % run_time)
print('Time for run: %s minutes' % run_time_min)

# for i in individuals:
#     print('strategies: ', i.strategy)
# print(traj)
# print(traj[exploit.Cell.stock])
# for key, d in traj.items():
#   print('key: ', key)
#   print('associated dict: ', d)
#   for k in d:
#       print('traj[key][v]: ',d[k])
